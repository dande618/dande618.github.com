---
layout: post
title: "Java数组"
date: 2013-02-01 20:29
comments: true
categories: JAVA
---
<h2>Java数组声明、创建、初始化</h2>
<p class="laiyuan">[转载]　<a href="http://developer.51cto.com/art/200906/128274.htm">文章出处</a></p>
<!-- more -->
一维数组的声明方式：
<p class="para">type var[]; 或type[] var;</p>
<p class="para">声明数组时不能指定其长度（数组中元素的个数）。</p>
<p class="para">Java中使用关键字new创建数组对象，格式为：</p>
<p class="para">数组名 = new 数组元素的类型 [数组元素的个数]</p>
TestNew.java：
程序代码：
{% codeblock lang:java %}
    public class TestNew  
    {  
         public static void main(String args[]) {  
             int[] s ;  
             int i ;  
             s = new int[5] ;  
             for(i = 0 ; i < 5 ; i++) {  
                 s[i] = i ;  
             }  
             for(i = 4 ; i >= 0 ; i--) {  
                 System.out.println("" + s[i]) ;  
             }  
         }   
    } 
{% endcodeblock %}
<h3>初始化：</h3>
<ol>
	<li>1.动态初始化：数组定义与为数组分配空间和赋值的操作分开进行；</li>
	<li>2.静态初始化：在定义数字的同时就为数组元素分配空间并赋值；</li>
	<li>3.默认初始化：数组是引用类型，它的元素相当于类的成员变量，因此数组分配空间后，每个元素也被按照成员变量的规则被隐士初始化。</li>
</ol>
<h3>TestD.java(动态)：</h3>
程序代码：
{% codeblock lang:java %}
    public class TestD  
    {  
         public static void main(String args[]) {  
             int a[] ;  
             a = new int[3] ;  
             a[0] = 0 ;  
             a[1] = 1 ;  
             a[2] = 2 ;  
             Date days[] ;  
             days = new Date[3] ;  
             days[0] = new Date(2008,4,5) ;  
             days[1] = new Date(2008,2,31) ;  
             days[2] = new Date(2008,4,4) ;  
         }  
    }  
     
    class Date  
    {  
         int year,month,day ;  
         Date(int year ,int month ,int day) {  
             this.year = year ;  
             this.month = month ;  
             this.day = day ;  
         }  
    }  
{% endcodeblock %}     
<h3>TestS.java(静态)：</h3>
程序代码：
{% codeblock lang:java %}
    public class TestS     
    {     
         public static void main(String args[]) {     
             int a[] = {0,1,2} ;     
             Time times [] = {new Time(19,42,42),new Time(1,23,54),new Time(5,3,2)} ;     
         }     
    }     
     
    class Time     
    {     
         int hour,min,sec ;     
         Time(int hour ,int min ,int sec) {     
             this.hour = hour ;     
             this.min = min ;     
             this.sec = sec ;     
         }     
    }    
{% endcodeblock %}  
<h3>TestDefault.java(默认)：</h3>
程序代码：
{% codeblock lang:java %}
    public class TestDefault     
    {     
         public static void main(String args[]) {     
             int a [] = new int [5] ;     
             System.out.println("" + a[3]) ;     
         }     
    }   
{% endcodeblock %}  
<h2>java数组</h2>
<p class="laiyuan">[转载]　<a href="http://www.cnblogs.com/iixiaowei/articles/2395937.html">文章出处</a></p>
<p class="para">1、java数组要求所有数据元素具有相同的数据类型。</p>
<p class="para">2、一旦数组的初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度将不可改变。</p>
<p class="para">　　即使把某个数组元素清空，但它所占的空间依然被保留，依然属于该数组，数组的长度依然不变。</p>
<p class="para">3、定义数组  type[] arrayName;</p>
<p class="para">4、数组是一种引用类型的变量，因此使用它定义一个变量时，仅仅表示定义了一个引用变量（也就是定义了一个指针），</p>
<p class="para">　　这个引用变量还未指向任何有效的内存，因此定义数组时不能指定数组的长度。</p>
<p class="para">　　而且由于定义数组仅仅只是定义了一个引用变量，并未指向任何有效的内存空间，所以还没有内存空间来存储数组元素，因此这个数组也不能使用，只有对数组进行初始化后，才可以使用。</p>
<p class="para">　　*定义数组时不能指定数组的长度  </p>                    
<p class="para">5、数组的初始化</p>
<p class="para">　　java语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。</p>
　　<p class="para">数组的初始化有两种方式：</p>
          <p class="para">1）静态初始化：初始化时由程序员显示指定每个数组元素的初始值，由系统决定需要的数组长度。</p>
<p class="para">　　语法：</p>
{% codeblock lang:java %}
		arrayName = new type[]{element1,element2,element3,element4...};
                   int[] intArr;
                   intArr = new int[]{5,6,8,20};
                   Object[] objArr;
                   objArr = new String[]{"java","ＬＬ"};
                   Object[] objArr2;
                   objArr2=new Object[]{"java","ＬＬ"};
 {% endcodeblock %} 
{% codeblock lang:java %}
                   //静态初始化还有如下简化的语法格式：
                   arrayName = {element1,element2,element3,element4...};
                   int[] a = {5,6,7,9};
 {% endcodeblock %}  
          2）动态初始化：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。
             动态初始化只指定数组的长度，由系统为每个数组元素指定初始值，动态初始化的语法格式如下：
{% codeblock lang:java %}
        arrName = new type[length];
                   int[] prices = new int[5];
                   Object[] books = new String[4];
 {% endcodeblock %}  
                   <p class="para">　　length属性可以获取数组的长度。</p>
 
         <p class="para">3）jdk1.5提供了foreach循环</p>
{% codeblock lang:java %}
            for(type variableName : array | collection){
                //variableName 自动迭代访问每个元素...
            }
  {% endcodeblock %}  
            <p class="para">　　* 使用foreach循环迭代数组元素时，并不能改变数组元素的值，因此不要对foreach的循环变量进行赋值。</p>
 
<p class="para">6、深入数组</p>
<p class="para">数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。下面将深入介绍数组在内存中的运行机制。</p>
 
<p class="para">6．1内存中的数组</p>
<p class="para">数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当该引用指向有效内存后，才可通过该数组变量来访问数组元素。</p>
<p class="para">与所有引用变量相同的是，引用变量是访问真实对象的根本方式。也就是说，如果我们希望在程序中访问数组，则只能通过这个数组的引用变量来访问它。</p>
 
<p class="para">实际的数组元素被存储在堆内存中；数组引用变量是一个引用类型的变量，被存储在栈内存中。</p>
 
<p class="para">如果堆内存中的数据不再有任何引用变量指向自己，则这个数组将成为垃圾，该数组所占的内存将会被系统的垃圾回收机制回收。因此，为了让垃圾回收一个数组所占的内存空间，则可以将该数组变量赋值为null，也就切断了数组引用变量和实际数组之间的引用关系，实际数组也就成了垃圾。</p>
 
<p class="para">6．2操作数组的工具类</p>
<p class="para">Java提供了Arrays类里包含了一些static修饰方法可以直接操作数组，这个Arrays类里包含了如下几个static修饰的方法(static修饰的方法可以直接通过类名调用)：</p>
|-public static int binarySearch(byte[] a,byte key):
<p class="para">使用二分法查询key元素值在a数组中出现的索引；如果a数组不包含key元素值，则返回负数。调用该方法时要求数组中元素已经按升序排列，这样才能得到正确结果。</p>
|-public static int binarySearch(byte[] a,int fromIndex, int toIndex,byte key)
<p class="para">搜索a数组中fromIndex到toIndex索引的元素。调用该方法时要求数组中元素已经按升序排列，这样才能得到正确结果。</p>
|-public static byte[] copyOf(byte[] original,int newLength)
<p class="para">将会把original数组复制成一个新数组，其中length是新数组的长度。如果length小于original数组的长度，则新数组就是原数组的前面length个元素；如果length大于original数组的长度，则新数组的前面元素就是原数组的所有元素，后面补充0（数值型）、false（布尔型）、或者null（引用型）。</p>
|-public static boolean[] copyOfRange(boolean[] original,int from,int to)
<p class="para">这个方法只复制original数组的from索引到to索引的元素。</p>
|-public static boolean equals(byte[] a, byte[] a2)
<p class="para">如果a数组a2数组的长度相等，而且a数组和a2数组的数组元素也一一相同，该方法将返回true。</p>
|-void fill(type[]a ,type val)
<p class="para">该方法将会把a数组所有元素值都赋值为val。</p>
|-void fill(type[] a, index fromIndex, int toIndex, type val)
<p class="para">区别只是该方法仅仅将a数组的fromIndex到toIndex索引的数组元素赋值为val</p>
|-void sort(type[] a):
<p class="para">该方法对a数组的数组元素进行排序</p>
|-void sort(type[] a,int fromIndex,int toIndex)
<p class="para">区别是该方法仅仅对fromIndex到toIndex。</p>
|-String toString(type[] a)
<p class="para">该方法将一个数组转换成一个字符串。该方法按顺序把多个数组元素连缀在一起，多个数组元素使用英文逗号，和空格隔开。</p>
{% codeblock lang:java %}
import java.util.*;
public class TestArrays
{
         public static void main(String[] args)
         {
              int[] a = new int[]{3,4,5,6};
                    int[] a2 = new int[]{3,4,5,6};
                    System.out.println("a数组和a2数组是否相等："+Arrays.equals(a,a2)); //true
                    int[] b = Arrays.copyOf(a,6);
                    System.out.println("a数组和b数组是否相等："+Arrays.equals(a,b)); //false
                    System.out.println("b数组的元素为："+Arrays.toString(b));
                    Arrays.fill(b,2,4,1);
                    System.out.println("b数组的元素为："+Arrays.toString(b));
                    Arrays.sort(b);
                    System.out.println("b数组的元素为："+Arrays.toString(b));
         }
}
 {% endcodeblock %}  