<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | 初心]]></title>
  <link href="http://dande618.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://dande618.github.com/"/>
  <updated>2013-02-16T16:52:52+08:00</updated>
  <id>http://dande618.github.com/</id>
  <author>
    <name><![CDATA[dande618]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[构造函数]]></title>
    <link href="http://dande618.github.com/blog/2012/12/31/gouzao/"/>
    <updated>2012-12-31T17:33:00+08:00</updated>
    <id>http://dande618.github.com/blog/2012/12/31/gouzao</id>
    <content type="html"><![CDATA[<p>　　构造函数（constructor）是人们完成结构化程序设计的一个新概念。在OO设计语言中，构造函数就是与类名同名而且没有返回类型的方法。</p>

<!-- more -->


<p>　　例如，Cabbie类的构造函数大致是：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="nf">Cabbie</span><span class="o">(){</span>
</span><span class='line'><span class="err">　　</span><span class="c1">//</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>　　编译器会识别出这个方法名与类名相同，从而认为这个方法是一个构造函数。</p>

<blockquote><p>构造函数没有返回值。如果为方法提供了一个返回值，编译器就不会把它作为一个构造函数。</p></blockquote>

<h2>何时调用构造函数</h2>

<p>　　创建一个新对象时，首先要做到事情之一就是调用构造函数。
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Cabbie</span> <span class="n">myCabbie</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cabbie</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
　　会实例化一个Cabbie对象，并调用Cabbie方法。</p>

<h2>构造函数中有什么</h2>

<p>　　构造函数中的代码应当将新创建的对象设置为其稳定、安全的初始状态。</p>

<p>　　初始化属性是构造函数完成的一个常见功能。</p>

<h2>默认构造函数</h2>

<p>　　至少存在一个构造函数，不论你自己是否编写了构造函数。如果你没有提供构造函数，系统也会为你提供一个默认的构造函数。例如，如果没有为Cabbie类提供一个构造函数，就会插入一下默认构造函数：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="nf">Cabbie</span><span class="o">(){</span>
</span><span class='line'><span class="err">　　</span><span class="kd">super</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
　　如果没有显式地继承另一个类，Object类就会成为父类。如果类中有属性，好的实践往往是初始化这些属性。</p>

<blockquote><p>提供一个构造函数</p>

<p>一般经验是，总是应该提供一个构造函数，即使你不打算在其中做任何事情。可以先提供一个构造函数，其中不包含任何内容，等以后再补充，使用编译器提供的默认构造函数尽管从技术上讲没什么问题，但是最好能清楚地知道你的代码到底是怎样的。</p></blockquote>

<h2>重载构造函数</h2>

<p>　　有时可能希望传入一个初始化参数，这成为重载一个方法。</p>

<p>　　重载适用于所有方法。重载允许程序员多次使用同一个方法名，只要每次方法的签名不同。签名由方法名和一个参数列表组成。
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Count</span> <span class="o">{</span>
</span><span class='line'><span class="err">　　</span><span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="n">Count</span><span class="o">(){</span>
</span><span class='line'><span class="err">　　　　</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="n">Count</span> <span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">){</span>
</span><span class='line'><span class="err">　　　　</span><span class="n">count</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
　　在JAVA和C#，返回类型不是签名的一部分。只是返回类型不同的方法会冲突。</p>

<h2>超类如何构造</h2>

<p>　　使用继承时，必须知道父类如何构造。要记住，使用继承时，会从父类继承一切。因此，必须非常清楚父类的所有数据和行为。不过，构造函数如何继承就不那么明显了。</p>

<p>　　遇到new关键字并且分配了对象后，会完成以下几个步骤。</p>

<ol>
<li><p>构造函数中首先要做的是调用该类的超类的构造函数。如果没有显式地调用超类构造函数，就会自动调用超类默认构造函数；不过可以从字节码查看这个代码。</p></li>
<li><p>然后初始化对象的各个类属性。这些属性都是类定义的属性（实例变量），而不是构造函数或其他方法中的属性（局部变量）。</p></li>
<li><p>然后执行构造函数中的其余代码。</p></li>
</ol>


<h2>构造函数的设计</h2>

<p>　　设计一个类时，好的时间是初始化所有属性。不要指望编译器来初始化属性。构造函数可以用来确保应用处于一种稳定的状态。例如，若将一个属性初始化为0，那么当想把它用作一个除法运算的除数时，可能会导致一个不稳定的应用。初始化为0并不总是最好的策略。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java动态绑定静态绑定 [转载]]]></title>
    <link href="http://dande618.github.com/blog/2012/12/29/bangding/"/>
    <updated>2012-12-29T10:01:00+08:00</updated>
    <id>http://dande618.github.com/blog/2012/12/29/bangding</id>
    <content type="html"><![CDATA[<!-- more -->


<p>　　首先是方法的参数是父类对象，传入子类对象是否可行。</p>

<p>　　然后引出Parent p = new Children();</p>

<p>　　这句代码不是很理解，google的过程中引出向上转型。</p>

<p>　　要理解向上转型又引出了动态绑定。</p>

<p>　　从动态绑定又引出了静态绑定。</p>

<h2>程序绑定的概念：</h2>

<p>　　绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。</p>

<h3>静态绑定：</h3>

<p>　　在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。例如：C。
针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。</p>

<h3>动态绑定：</h3>

<p>　　后期绑定：在运行时根据具体对象的类型进行绑定。
　　若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p>

<ul>
<li><p>动态绑定的过程：</p></li>
<li><p>虚拟机提取对象的实际类型的方法表；</p></li>
<li><p>虚拟机搜索方法签名；</p></li>
<li><p>调用方法。</p></li>
</ul>


<h2>关于绑定相关的总结：</h2>

<p>　　在了解了三者的概念之后，很明显我们发现java属于后期绑定。在java中，几乎所有的方法都是后期绑定的，在运行时动态绑定方法属于子类还是基类。但是也有特殊，针对static方法和final方法由于不能被继承，因此在编译时就可以确定他们的值，他们是属于前期绑定的。特别说明的一点是，private声明的方法和成员变量不能被子类继承，所有的private方法都被隐式的指定为final的(由此我们也可以知道：将方法声明为final类型的一是为了防止方法被覆盖，二是为了有效的关闭java中的动态绑定)。java中的后期绑定是有JVM来实现的，我们不用去显式的声明它，而C++则不同,必须明确的声明某个方法具备后期绑定。</p>

<p>　　java当中的向上转型或者说多态是借助于动态绑定实现的，所以理解了动态绑定，也就搞定了向上转型和多态。
前面已经说了对于java当中的方法而言，除了final，static，private和构造方法是前期绑定外，其他的方法全部为动态绑定。而动态绑定的典型发生在父类和子类的转换声明之下：</p>

<p>　　比如：Parent p = new Children();</p>

<p>其具体过程细节如下：</p>

<ol>
<li><p>编译器检查对象的声明类型和方法名。假设我们调用x.f(args)方法，并且x已经被声明为C类的对象，那么编译器会列举出C类中所有的名称为f的方法和从C类的超类继承过来的f方法。</p></li>
<li><p>接下来编译器检查方法调用中提供的参数类型。如果在所有名称为f 的方法中有一个参数类型和调用提供的参数类型最为匹配，那么就调用这个方法，这个过程叫做“重载解析”。</p></li>
<li><p>当程序运行并且使用动态绑定调用方法时，虚拟机必须调用同x所指向的对象的实际类型相匹配的方法版本。假设实际类型为D(C的子类)，如果D类定义了f(String)那么该方法被调用，否则就在D的超类中搜寻方法f(String),依次类推。</p></li>
</ol>


<p>　　上面是理论，下面看几个示例（示例来自网络）：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">view</span> <span class="n">plaincopy</span> <span class="n">to</span> <span class="n">clipboardprint</span><span class="o">?&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Father</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">method</span><span class="o">()</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;父类方法，对象类型：&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Father</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">Father</span> <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Son</span><span class="o">();</span><span class="c1">//向上转型  &lt;br/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">sample</span><span class="o">.</span><span class="na">method</span><span class="o">();</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
　　声明的是父类的引用，但是执行的过程中调用的是子类的对象，程序首先寻找子类对象的method方法，但是没有找到，于是向上转型去父类寻找。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Father</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">method</span><span class="o">()</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;子类方法，对象类型：&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">Father</span> <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Son</span><span class="o">();</span><span class="c1">//向上转型  &lt;br/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">sample</span><span class="o">.</span><span class="na">method</span><span class="o">();</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
　　由于子类重写了父类的method方法，根据上面的理论知道会去调用子类的method方法去执行，因为子类对象有method方法而没有向上转型去寻找</p>

<p>　　前面的理论当中已经提到了java的绑定规则，由此可知，在处理java类中的成员变量时，并不是采用运行时绑定，而是一般意义上的静态绑定。所以在向上转型的情况下，对象的方法可以找到子类，而对象的属性还是父类的属性。
代码如下：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Father</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">　　</span><span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;父亲属性&quot;</span><span class="o">;</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">method</span><span class="o">()</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;父类方法，对象类型：&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Father</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;儿子属性&quot;</span><span class="o">;</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">method</span><span class="o">()</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;子类方法，对象类型：&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">Father</span> <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Son</span><span class="o">();</span><span class="c1">//向上转型  &lt;br/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;调用的成员：&quot;</span><span class="o">+</span><span class="n">sample</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
结论，调用的成员为父亲的属性。
　　这个结果表明，子类的对象(由父类的引用handle)调用到的是父类的成员变量。所以必须明确，运行时（动态）绑定针对的范畴只是对象的方法。
　　现在试图调用子类的成员变量name，该怎么做？最简单的办法是将该成员变量封装成方法getter形式。
代码如下：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Father</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;父亲属性&quot;</span><span class="o">;</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">method</span><span class="o">()</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;父类方法，对象类型：&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Father</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;儿子属性&quot;</span><span class="o">;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'><span class="err">　　　</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">method</span><span class="o">()</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;子类方法，对象类型：&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">Father</span> <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Son</span><span class="o">();</span><span class="c1">//向上转型  &lt;br/&gt;</span>
</span><span class='line'><span class="err">　　　</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;调用的成员：&quot;</span><span class="o">+</span><span class="n">sample</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="err">　　</span><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
结果：调用的是儿子的属性</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何以对象方式思考（二）]]></title>
    <link href="http://dande618.github.com/blog/2012/12/26/haw_to2/"/>
    <updated>2012-12-26T20:01:00+08:00</updated>
    <id>http://dande618.github.com/blog/2012/12/26/haw_to2</id>
    <content type="html"><![CDATA[<p>　　ＯＯ设计的基本单元是类。ＯＯ设计所期望的最终结果是一个健壮、功能完备的对象模型，换句话说，也就是一个完备的系统。</p>

<!-- more -->


<h2>确定用户</h2>

<p>　　用户是那些真正使用系统的人。设想一个出租车的例子，压迫构建一个现实而可用的接口，要把顾客和出租司机双方都认为是用户。</p>

<h2>对象行为</h2>

<p>　　明确用户只是工作的一部分。明确用户后，必须确定对象的行为。要从所有用户的角度考虑，明确每个对象的作用以及必须要做什么才能执行。</p>

<h2>环境约束</h2>

<p>　　环境通常会限制对象能够做什么。</p>

<h2>明确公共接口</h2>

<p>　　收集到有关用户、对象行为和环境的所有信息后，需要确定每个用户的公共接口。</p>

<p><strong>考虑如何使用出租车对象：</strong></p>

<ol>
<li><p>坐进出租车。</p></li>
<li><p>告诉出租司机你要去哪里。</p></li>
<li><p>给出租司机付车费。</p></li>
<li><p>下车。</p></li>
</ol>


<p><strong>使用出租车对象需要做：</strong></p>

<ol>
<li><p>明确要去一个地方。</p></li>
<li><p>叫一辆出租车。</p></li>
<li><p>给出租司机付钱。</p></li>
</ol>


<p>　　开始时，要考虑对象如何使用，而不是它如何构建。确定最终的接口是一个迭代的过程。对于每个接口，必须确定这个接口有助于对象的操作。如果没有，就可能是不必要的。</p>

<h2>明确实现</h2>

<p>　　选择了公共接口之后，就需要明确实现。考虑类工作的具体细节。</p>

<p>　　不属于公共接口的所有部分都认为是实现。用户不会看到作为实现的任何方法，包括方法的签名（其中包括方法名和参数列表）以及方法中的具体代码。</p>

<p>　　可以有一个私有方法，由类在内部使用。所有私有方法都认为是实现的一部分，用户不会看到它，从而也无法访问私有方法。实现对用户是完全隐藏的。</p>

<p>　　从理论上讲，被认为是实现的任何部分可以改变而不影响类的用户接口。接口表示了用户如何看对象，而实现实际上是对象的具体内容。实现包含了表示对象状态的代码。</p>

<p>摘自《写给大家看的面向对象编程书》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何以对象方式思考（一）]]></title>
    <link href="http://dande618.github.com/blog/2012/12/26/haw_to1/"/>
    <updated>2012-12-26T20:01:00+08:00</updated>
    <id>http://dande618.github.com/blog/2012/12/26/haw_to1</id>
    <content type="html"><![CDATA[<p>　　ＯＯ设计的基本单元是类。ＯＯ设计所期望的最终结果是一个健壮、功能完备的对象模型，换句话说，也就是一个完备的系统。</p>

<!-- more -->


<p>　　解决一个问题没有纯粹的对与错，同一个问题往往可能有多种不同的处理方法。所以识图设计一个ＯＯ解决方案时，不要想着一上来就完成一个完美的设计（总会有需要改进的地方）。真正需要的是进行头脑风暴，让你能从不同方向展开你的思维过程。尝试解决一个问题时，不要试图遵照任何标准或约定，因为关键就是要有创造性。</p>

<p>　　实际上，这个过程开始时，甚至不要考虑特定的编程语言。首要的是找出并解决业务问题。首先完成概念分析和设计。只有当特定技术对于解决业务问题至关重要时采取考虑它，例如，如果脱离无线技术可能无法设计一个无线网络。不过，通常有多种软件解决方案可以考虑。</p>

<p>　　要培养善于完成ＯＯ思维过程的敏锐判断力，要注意3个重要的方面</p>

<ol>
<li><p>了解接口和实现之间的区别；</p></li>
<li><p>以更抽象的方式思考；</p></li>
<li><p>尽可能为用户提供最小接口。</p></li>
</ol>


<h2>了解接口与实现之间的区别</h2>

<p>　　构建强大的ＯＯ设计时，关键是理解接口与实现之间的区别。因此，在设计类时，必须了解用户需要知道什么以及用户不需要知道什么，这些是至关重要的。可以利用封装所固有的数据隐藏机制将不重要的数据对用户隐藏。</p>

<blockquote><p><strong>用户看什么：</strong></p>

<p>接口也与类直接相关。最终用户通常不会看任何类，他们只看GUI或命令行界面。不过，程序员会看类接口。类重用意味着已经有人编写了一个类。因此程序员要使用一个类，就必须知道如何让这个类正确地工作。这个程序员要结合多个类来创造一个系统，他需要理解类的接口。因此，这一张谈到用户时，我们主要是指设计人员和开发人员，而不一定是最终用户。因此，在这个上下文中讨论接口时，也会死指类接口，而不是GUI。</p></blockquote>

<h2>接口</h2>

<p>　　为最终用户提供的服务构成了接口。最理想的情况下，应当只为最终用户提供他们所需要的服务。</p>

<blockquote><p><strong>明确用户：</strong></p>

<p>设计一个类时，也许最重要的就是要明确受众或用户。</p></blockquote>

<h2>实现</h2>

<p>　　实现细节对用户是隐藏的。一定要记住实现的一个目标：改变实现不需要同时改变用户的代码。这可能让人有些不太明白，不过，这个目标正是设计的核心问题。如果接口得到了正确的设计，对实现的改变就不会导致用户代码的改变。要记住，接口包含调用一个方法以及返回一个值的语法。如果这个接口没有改变，用户就不关心实现是否发生了改变。只要程序员可以使用同样的语法获取同样的值，怎样实现都无所谓。</p>

<p>　　用户和实现都必须遵循接口规范。</p>

<blockquote><p><strong>对象持久性：</strong></p>

<p>对象持久性（Objiect persistence）是指保存对象的状态，从而可以在以后恢复并使用，没有持久存储的对象一旦出了作用域实际上就已经“死亡”。例如，可以把对象的状态保存在数据库中。</p></blockquote>

<h2>设计接口时使用抽象思维</h2>

<p>　　ＯＯ程序设计的主要优点之一是类可以重用。一般地，可重用类的接口往往更抽象而不是更具体。具体接口通常非常特定，而抽象接口更为一般。不过，如果说一个高度抽象的接口比一个想到具体的接口更有用，则不尽然（尽管通常都是如此）。</p>

<p>　　我们的目标是设计抽象、高度可重用的类，为此，我们要设计高度抽象的用户接口。</p>

<h2>尽可能为用户提供最小接口</h2>

<p>　　设计类时，一般经验是总是为用户尽可能少地提供类的内部知识。为做到这一点，要遵循以下简单规则。</p>

<ul>
<li><p>只为用户提供他们确实需要的东西。实际上，这意味着类的接口要尽可能少。开始设计一个类时，首先只应有最小接口。类的设计是迭代性的，所以你很快会发现最小接口可能不能满足需求。这很正常。</p></li>
<li><p>最好是当用户确实需要时才增加接口，而不要为用户提供他们不需要的接口。在很多情况下，为用户提供某些接口会带来问题。</p></li>
<li><p>公共接口定义用户能访问的信息。如果开始时将接口置为私有，使整个类对用户隐藏，那么当程序员开始使用这个类时，会要求你将某些方法置为公共，这些方法就会成为公共接口。</p></li>
</ul>


<p>摘自《写给大家看的面向对象编程书》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[继承与组合]]></title>
    <link href="http://dande618.github.com/blog/2012/12/24/is_a_has_a/"/>
    <updated>2012-12-24T22:11:00+08:00</updated>
    <id>http://dande618.github.com/blog/2012/12/24/is_a_has_a</id>
    <content type="html"><![CDATA[<p>　　is-a表示的是属于得关系。代表类之间或类与接口的继承关系。比如兔子属于一种动物（继承关系）。</p>

<p>　　has-a表示组合，包含关系。代表对象和他成员的从属关系。比如兔子包含有腿，头等组件；就不能说兔子腿是属于一种兔子（不能说是继承关系）</p>

<!-- more -->


<p>　　对两个类之间"is a"或是"has a"关系的分析，有助于我们确定它们之间是否存在继承关系，避免设计上的错误，因而达到提高代码重用性的目的。</p>

<p>　　在JAVA中，组合仅需将对象引用置于新类中即可。</p>

<p>　　继承以关键字extends实现，即BaseClass extends SubClass{ }的形式实现导出类由BaseClass导出子类SubClass，子类可以在其接口中自动获取基类的方法而不论这些方法是否在子类中显示定义过；一方面，在子类中使用基类中的方法及对其进行修改都是可行的。需要特别说明的是，若要使用子类与基类中共有的属于基类方法时，则需要加关键字super表示当前类是从超类继承来的。</p>

<p><strong>继承：</strong>
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">A</span><span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span> <span class="c1">//.....</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">A</span><span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//.....</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<strong>组合：</strong>
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">A</span><span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//.....</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">B</span><span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span> <span class="n">A</span> <span class="n">a</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
</feed>
